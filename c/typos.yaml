rules:
  - id: raptor-typos
    metadata:
      author: Marco Ivaldi <raptor@0xdeadbeef.info>
      references:
        - https://cwe.mitre.org/data/definitions/480
        - https://cwe.mitre.org/data/definitions/481
        - https://cwe.mitre.org/data/definitions/482
        - https://cwe.mitre.org/data/definitions/483
        - https://g.co/kgs/PCHQjJ
        - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
      confidence: LOW
      # NOTE: common issues with comments are not covered.
      # NOTE: constructs such as assert(var == val) lead to false positives.
    message: >-
      The programmer accidentally uses the wrong operator, which changes
      the application logic in security-relevant ways. This rule also covers 
      some other common typo patterns.
    severity: INFO
    languages:
      - c
      - cpp
    pattern-either:
      # == instead of = in assignment (the ternary operator is not supported by Semgrep)
      - pattern: for ($EXPR1 == $EXPR2; $EXPR3; $EXPR4) ...
      - pattern: $EXPR1 == $EXPR2;
      # = instead of == in comparison
      - patterns:
        - pattern: if (<... $EXPR1 = $EXPR2 ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) == $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) != $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) < $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) <= $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) > $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) >= $EXPR ...>) ...
      # & instead of && in comparison
      - patterns:
        - pattern: if (<... $EXPR1 & $EXPR2 ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) == $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) != $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) < $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) <= $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) > $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) >= $EXPR ...>) ...
      # | instead of || in comparison
      - patterns:
        - pattern: if (<... $EXPR1 | $EXPR2 ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) == $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) != $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) < $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) <= $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) > $EXPR ...>) ...
        - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) >= $EXPR ...>) ...
      # =+ instead of += (and =- instead of -=)
      - pattern: $EXPR1 =+ $EXPR2
        # - pattern: $EXPR1 =- $EXPR2
      # ; at the end of if() or for() statement
      - pattern: if ($COND);
      - pattern: for ($EXPR1; $EXPR2; $EXPR3);
      # accidental octal conversion
      - patterns:
        - pattern-either:
          - pattern: $TYPE $ARR[$SIZE];
          - pattern: $TYPE $ARR[$SIZE] = $EXPR;
        - metavariable-regex:
            metavariable: $SIZE
            regex: '^0.*'
      # missing {} in if() statement (too many false positives)
        # - pattern: if ($COND) $BODY;
