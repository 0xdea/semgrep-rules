rules:
  - id: raptor-interesting-api-calls
    metadata:
      author: Marco Ivaldi <raptor@0xdeadbeef.info>
      references:
        - https://github.com/0xdea/rhabdomancer
        - https://github.com/0xdea/ghidra-scripts/blob/main/Rhabdomancer.java
        - https://github.com/x509cert/banned/blob/master/banned.h
        - https://g.co/kgs/PCHQjJ
        - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
        - https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/28719-banned-api-usage-use-updated-function-replacement
      confidence: MEDIUM
      # NOTE: `goto`, `try/catch`, `sem/mutex`, `new/delete`, and 
      # `static_cast/reinterpret_cast` are not covered.
      # NOTE: consider excluding some matches for `strncpy`, `snprintf`, and similar
      # functions where the length parameter is known at compile time (see `memcpy`
      # below for an example). See also another possible approach described at
      # https://cc-sw.com/semgrep-guide-for-a-security-engineer-part-6-of-6/.
      # Beware of possible false negatives, though.
      # NOTE: consider checking for format string specifiers that match the
      # `(".*%l?s.*"|".*%S.*"|[a-zA-Z_][a-zA-Z0-9_]*)` regex.
      # NOTE: consider extracting some patterns into separate rules to focus on
      # the most interesting API calls (copy operations, exec functions, etc.).
      # NOTE: see also https://semgrep.dev/r?lang=C
    message: >-
      Locate all calls to interesting and potentially insecure API
      functions (candidate points). The auditor can backtrace from these
      candidate points to find pathways allowing access from untrusted
      input.
    severity: WARNING
    languages:
      - c
      - cpp
    pattern-either:
      # priv
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*set\w*(u|g)id\s*$|^\w*(init|set)groups\s*$'
      # strcpy
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*str\w?cpy(_s)?(_l)?\s*$|^\w*stpn?cpy(_s)?(_l)?\s*$|^\w*(wc|mb)s\w?cpy(_s)?(_l)?\s*$|^\w*wcpn?cpy(_s)?(_l)?\s*$'
      # strcat
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*str\w?cat(_s)?(_l)?\s*$|^\w*(wc|mb)s\w?cat(_s)?(_l)?\s*$'
      # strtok
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*strtok(_s)?(_l)?\s*$|^\w*(wc|mb)stok(_s)?(_l)?\s*$'
      # strlen (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*(str|wcs|mbs)n?len\s*$'
      # printf
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*s\w?printf(_s)?(_l)?\w*\s*$'
      # more printf (should be covered by format-string-bugs rule)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*printf\w*\s*$|^\w*err\w*\s*$|^\w*warn\w*\s*$|^\w*syslog\w*\s*$'
      # scanf
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*scanf(_s)?(_l)?\s*$'
      # get
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*get(s|c|char|pw|pass|wd|cwd|opt|opt_long)\s*$'
      # environment
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*(get|set|put|unset)env\s*$'
      # memcpy
      - patterns:
          - pattern: $FUN($_, $_, $LEN, ...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*memc?cpy(_s)?\s*$|^\w*memmove(_s)?\s*$|^\w*bcopy\s*$'
          # exclude length known at compile time (sizeof macro)
          - pattern-not: $FUN($_, $_, sizeof(...), ...)
          # - pattern-not: $FUN($_, $_, <... sizeof(...) ...>, ...)
          # exclude length known at compile time (numeric literal)
          - metavariable-regex:
              metavariable: $LEN
              regex: '^(?!\s*(?:0[xX][0-9A-Fa-f]+|0[bB][01]+|0[0-7]*|[1-9][0-9]*)[uUlL]*\s*$).+'
      # memset (too noisy, likely irrelevant)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*memset(_explicit)?\s*$'
      # alloc
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*alloc(a|f)?\s*$|^\w*alloc_?array\s*$'
      # free (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*free\s*$'
      # exec
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*exec(l|v)?(p|e)?e?\s*$|^\w*system\s*$'
      # i/o
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*open(at)?(64)?\s*$|^\w*pipe\s*$|^\w*read\s*$|^\w*recv(from)?\s*$'
      # more i/o (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*connect\s*$|^\w*write\s*$|^\w*hton(l|s)\s*$|^\w*ntoh(l|s)\s*$'
      # proc
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*fork\s*$'
      # more proc (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*clone\s*$'
      # rand
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*rand\s*$'
      # tmp
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*mk\w?temp(64)?\s*$|^\w*te?mpnam\s*$|^\w*tmpfile\s*$'
      # file
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*mkdir\s*$|^\w*creat\s*$|^\w*link(at)?\s*$|^\w*rename(at)?\s*$|^\w*access(at|_ok)?\s*$|^\w*stat(at)?\s*$|^\w*ch(own|mod)(at)?\s*$|^\w*realpath(at)?\s*$|^\w*readlink\s*$'
      # more file
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*locale\s*$|^\w*(make|split)path\s*$'
      # signals (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*kill\s*$|^\w*signal\s*$|^\w*sigaction\s*$|^\w*(set|long)jmp\s*$'
      # time (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*time\s*$'
      # kernel
      - patterns:
          - pattern: $FUN(...)
          - metavariable-regex:
              metavariable: $FUN
              regex: '(?i)^\w*copy_(from|to)_user\s*$|^\w*(get|put)_user\s*$|^\w*copy(in|out)\s*$'
      # more kernel (too noisy)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*cpu_to_(b|l)e(16|32|64)(p|s)?\s*$|^\w*(b|l)e(16|32|64)(p|s)?_to_cpu\s*$|^\w*xb_get_(32|64|bytes|word_array|bitmap)\s*$'
      # assert (should be covered by suspicious-assert rule)
      # - patterns:
      # - pattern: $FUN(...)
      # - metavariable-regex:
      # metavariable: $FUN
      # regex: '(?i)^\w*assert\w*\s*$'
      # switch (too noisy)
      # - pattern: |
      # switch ($VAR) { }
