rules:
  - id: raptor-typos
    metadata:
      author: Marco Ivaldi <raptor@0xdeadbeef.info>
      references:
        - https://cwe.mitre.org/data/definitions/480
        - https://cwe.mitre.org/data/definitions/481
        - https://cwe.mitre.org/data/definitions/482
        - https://cwe.mitre.org/data/definitions/483
        - https://g.co/kgs/PCHQjJ
        - https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf
      confidence: LOW
      # NOTE: common issues with comments are not covered.
      # NOTE: consider adding a `focus-metavariable` where applicable to
      # improve output readability.
      # NOTE: custom wrappers to assertion macros are not covered.
    message: >-
      The programmer accidentally uses the wrong operator, which changes
      the application logic in security-relevant ways. This rule also covers
      some other common typo patterns.
    severity: INFO
    languages:
      - c
      - cpp
    pattern-either:
      # == instead of = in assignment (the ternary operator is not supported by Semgrep)
      - pattern: for ($_ == $_; $_; $_) ...
      - patterns:
          - pattern: $_ == $_;
          - pattern-not-inside: return $_;
          - pattern-not-inside: assert(...);
      # = instead of == in comparison
      - patterns:
          - pattern: if (<... $EXPR1 = $EXPR2 ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) == $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) != $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) < $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) <= $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) > $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 = $EXPR2) >= $_ ...>) ...
      # & instead of && in comparison
      - patterns:
          - pattern: if (<... $EXPR1 & $EXPR2 ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) == $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) != $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) < $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) <= $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) > $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 & $EXPR2) >= $_ ...>) ...
      # | instead of || in comparison
      - patterns:
          - pattern: if (<... $EXPR1 | $EXPR2 ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) == $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) != $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) < $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) <= $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) > $_ ...>) ...
          - pattern-not-inside: if (<... ($EXPR1 | $EXPR2) >= $_ ...>) ...
      # =+ instead of += (and =- instead of -=)
      - pattern: $_ =+ $_
        # - pattern: $EXPR1 =- $EXPR2
      # duplicate expressions
      - pattern: ($EXPR && $EXPR)
      - pattern: ($EXPR || $EXPR)
      - pattern: ($EXPR == $EXPR)
      - pattern: ($EXPR != $EXPR)
      - pattern: ($EXPR < $EXPR)
      - pattern: ($EXPR <= $EXPR)
      - pattern: ($EXPR > $EXPR)
      - pattern: ($EXPR >= $EXPR)
      # assigning or comparing a char literal to a pointer (some types and literals are missing)
      - pattern: (char * $_) = '\0'
      - pattern: (char * $_) == '\0'
      - pattern: (char * $_) != '\0'
      # use of a string copy function instead of a string compare function in a condition
      - pattern: if (<... strcpy(...) ...>) ...
      - pattern: if (<... strncpy(...) ...>) ...
      # ; at the end of if or for statement (empty else block not covered)
      - pattern: if ($_);
      - pattern: for ($_; $_; $_);
      # accidental octal conversion
      - patterns:
          - pattern-either:
              - pattern: $_ $_[$LEN];
              - pattern: $_ $_[$LEN] = $_;
          - metavariable-regex:
              metavariable: $LEN
              regex: "^0[^xX].*"
      # missing {} in if statement (too many false positives)
      # - pattern: if ($COND) $BODY;
